%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Operations %%
((operators and or not imp))
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Control Flow %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% For (smallProver T PREMISES CONCLUSION STEPS), the variables are:
%    - T: just cnf for now
%    - PREMISES: a list of premises  
%    - CONCLUSION: a single proposition as the conclusion
%    - STEPS: An ordered list of Rules of Inference (roi) to prove conclusion
% 
% Typically T, PREMISES, and CONCLUSION will be treated
% as input and STEPS will be taken to be output.  
% 
% NOTE: Does at most 2 steps (as specified in homework description)
% 
% NOTE: Sensitive to extraneous parentheses
% 

% Tautologies
((smallProver _ PREM CONCL ())
	(member CONCL PREM))

% Single step proof
((smallProver cnf PREM CONCL (S1))
	(pairos PAIR PREM)
	(roi S1 PAIR L)
	(member CONCL L))

% Two step proof
((smallProver cnf PREM CONCL (S1 S2))
	(pairos PAIR PREM)
	(roi S1 PAIR OUTCOME)
	(uniqapp OUTCOME PREM NEWPREM)
	(smallProver cnf NEWPREM CONCL (S2)))

%((smallProver cnf PREM CONCL (H3|T3))
%	(roi H3 PREM OUTPUT1)
%	(smallProver cnf OUTPUT1 CONCL T3))

%((smallProver cnf _ () ())(pp "Premises Proven to be Conclusion"))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% End Control Flow %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Rules of Inferences
%% -only applies once to a given formula (Even if it could be applied twice or more)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% (not not A) = (A)
% (not not (not not A)) = ((not not A))
%((doubleNegation () ()))
((roi doubleNegation ((not not A)) (A)))
((roi doubleNegation ((not not A)) (A)))
((roi doubleNegation ((not (not A))) (A)))
((roi doubleNegation ((not (not A))) (A)))
%((roi doubleNegation (not not A|T)(A|T)))
%((doubleNegation (H1|T1)(H1|T2))
	%(doubleNegation T1 T2))

% (not (A and B)) = ((not A) or (not B))
% (not (A or B)) = ((not A) and (not B))
%((deMorgan () ()))
((roi deMorgan ((not (A and B))) (((not A) or (not B)))))
((roi deMorgan ((not (A or B))) (((not A) and (not B)))))
%((deMorgan (H1|T1)(H1|T2))
%	(deMorgan T1 T2)(pp "3"))

((roi AndIntroduction (A B) ((A and B))))
((roi AndIntroduction (A B) ((B and A))))
	
%((roi AndElimination ()()))
((roi AndElimination ((A and B)) (A B)))
((roi AndElimination ((A and B)) (B A)))

((roi ModusPonens ((A imp B) A) (B)))
((roi ModusPonens (A (A imp B)) (B)))

%((roi OrIntroduction (A) ((A or B))))
%((roi OrIntroduction (A) ((B or A))))

((roi UnitResolution ((A or B) (not A)) (B)))
((roi UnitResolution ((A or B) (not B)) (A)))
((roi UnitResolution ((not A) (A or B)) (B)))
((roi UnitResolution ((not B) (A or B)) (A)))

((roi Resolution ((A or B)((not A) or C))((B or C))))
((roi Resolution ((A or B)((not B) or C))((A or C))))
((roi Resolution ((A or B)((not A) or C))((C or B))))
((roi Resolution ((A or B)((not B) or C))((C or A))))
((roi Resolution ((A or B)(C or (not A)))((B or C))))
((roi Resolution ((A or B)(C or (not B)))((A or C))))
((roi Resolution ((A or B)(C or (not A)))((C or B))))
((roi Resolution ((A or B)(C or (not B)))((C or A))))
((roi Resolution (((not A) or C)(A or B))((B or C))))
((roi Resolution (((not B) or C)(A or B))((A or C))))
((roi Resolution (((not A) or C)(A or B))((C or B))))
((roi Resolution (((not B) or C)(A or B))((C or A))))
((roi Resolution ((C or (not A))(A or B))((B or C))))
((roi Resolution ((C or (not B))(A or B))((A or C))))
((roi Resolution ((C or (not A))(A or B))((C or B))))
((roi Resolution ((C or (not B))(A or B))((C or A))))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% End Rules of Inference
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Helper Functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Should Remove Extra Parenthesis
% Single element lists unnecessary
((cleanop (A) B)(cleanop A B)(!))
((cleanop (H1|(T1|(TX|TT))) (H2|T2))
	(cleanop H1 H2)
	(cleanop (T1|(TX|TT)) T2)(!))
((cleanop (H1|T1) (H2|(T2)))
	(cleanop H1 H2)
	(cleanop T1 T2)(!))
((cleanop (A) A)(!))
((cleanop A A)(!))

% Cleans, but makes sure a single list remains on the outside 
((clean A (L))
	(cleanop A L)
	(negg islist L)(!))
((clean A L)(cleanop A L)(!))

((islist (L)))
((islist (H|T)))

%((test (H|T) H)(pp H)(pp T))

% First argument is an unordered pair of the second argument
% (i.e., A always before B in second argument)
((pair (A B) (A|T))
	(member B T))

((pair (A B) (_|T))
	(pair (A B) T))

% Produces pairs or singletons 
((pairos P L)(pair P L))
((pairos (S) L)(member S L))

% Last argument is a list which is the second argument L with A added to it
% (if A is not already in L -- otherwise the last argument is exactly L)
((uniqconcat A L (A|L))
	(negg member A L)(!))

((uniqconcat A L L)(!))

% All members of first argument are added to second argument
% if not already present
((uniqapp (H|T) L L1)
	(uniqconcat H L L2)
	(uniqapp T L2 L1)(!))
((uniqapp () L L)(!))

% Holds if first argument is subset of second argument
((subset (H|T) L)
	(member H L)
	(negg member H T)
	(subset T L))
((subset () L))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% End Helper Functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% List Processing 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Holds if arg1 is a member of arg2
((member H (H|_)))
((member E ( _|T))
	(member E T))

% Counts the length of arg1 and outputs into arg2
((length () 0 ))
((length (_|T) N)
	(length T N1)
	(sum N1 1 N))

% Appends arg1 to arg2 resulting in arg3 (adds to the left)
((append () L L))
((append (H1|T1) L2 (H1|T))
    (append T1 L2 T))

% replaces arg1 in arg2 with arg3 to output arg4
((substitute _ () _ () )) 
((substitute H (H|T) H2 (H2 | T2)) 
	(substitute H T H2 T2) 
    (!)) 
((substitute H (H1|T1) H2 (H1|T2))
    (substitute H T1 H2 T2)) 

% Removes arg1 from arg2 and outputs to arg3
((remove _ () ()))
((remove H (H|T) T))

((remove I (H1|T1) (H1|T2))
	(remove I T1 T2))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% End List Processing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%